import sys
import math
import random
import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
from time import time

class DoubleWell():
    '''
    Contains functions relevant to Double Well potential model.

    params [dict]: Parameters that define the double well: k_x, x_0, k_BH, k_y
    xmin [float]: xmin applied to plots generated by plotting functions in this class
    xmax [float]: As above but xmas
    ymin [float]: As above but ymin
    ymax [float]: As above but ymas
    '''

    def __init__(self, params=None,
                 xmin=None, xmax=None, ymin=None, ymax=None):
        self.params = params
        self.xmin = xmin
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax

    def energy(self, X, input_mode='Traj'):
        '''
        Takes path(s) and returns the energy 

        X [numpy array]: Array containing the path(s)
        input_mode ['Traj' or 'Batch']: Does X contain a simple path, or a batch of paths?
        '''
        if input_mode == 'Traj':
            x = X[:,0]
            y = X[:,1]
        if input_mode == 'Batch':
            x = X[:,:,0]
            y = X[:,:,1]
        
        E = ((self.params['k_x']*((x**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y**2))) * self.params['k_BH']
        
        return E

    def batch_gradient(self, X, mode, dX=0.001):
        '''
        Returns the gradient of the energy of the paths passed to it. 

        X [numpy array]: Array containing the path(s)
        mode ['numpy' or 'TF']: Should this function use numpy or tensorflow operations. Use 'TF' when calling this as part of network training. 
        dX [float]: Delta used for numerical differentiation
        '''
        x = X[:,:,0]
        y = X[:,:,1]
        
        x_pl_dX = x + dX
        x_mi_dX = x - dX
        x_pl_Energy = ((self.params['k_x']*((x_pl_dX**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y**2))) * self.params['k_BH']
        x_mi_Energy = ((self.params['k_x']*((x_mi_dX**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y**2))) * self.params['k_BH']
        grad_Ux = (x_pl_Energy - x_mi_Energy)/(2*dX)

        y_pl_dX = y + dX
        y_mi_dX = y - dX
        y_pl_Energy = ((self.params['k_x']*((x**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y_pl_dX**2))) * self.params['k_BH']
        y_mi_Energy = ((self.params['k_x']*((x**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y_mi_dX**2))) * self.params['k_BH']
        grad_Uy = (y_pl_Energy - y_mi_Energy)/(2*dX)

        if mode == 'numpy':
            grad_U = np.stack((grad_Ux, grad_Uy), axis=2)
        elif mode == 'TF':
            grad_U = tf.stack((grad_Ux, grad_Uy), axis=2)
        
        return grad_U

    def plot_free_energy(self):
        '''
        Plots the changes in free energy with x_1
        '''
        x_1s = np.linspace(-2,2, 200)[:,None]
        x_2s = np.zeros((x_1s.size,1))
        Xs = np.hstack((x_1s, x_2s))
        energies = self.energy(Xs)
        
        import matplotlib.pyplot as plt
        ax = plt.gca()
        ax.set_xlabel('$x_1$ / a.u.')
        ax.set_ylabel('Energy / kT')
        ax.set_ylim(energies.min()-2, energies[int(energies.size/2)]+2.5)
        
        return ax.plot(x_1s, energies, linewidth=3, color='black')      
   
    def plot_energy_surface(self, x_lim=2):
        '''
        Generates a contour plot showing the energy landscape

        x_lim [float]: Defines xmax, xmin, ymax, ymin of the plot. 
        '''
        plt.rcParams['figure.figsize'] = 18, 12
        cmax = 50

        # Calculate Energies for Main Plot
        x_1s = np.linspace(-x_lim,x_lim, 100)
        X1grid, X2grid = np.meshgrid(x_1s, x_1s) # x_2s = x_1s
        Xs = np.vstack([X1grid.flatten(), X2grid.flatten()]).T
        energies = self.energy(Xs)
        energies = energies.reshape((100,100))
        energies = np.minimum(energies,cmax)          
        ##### Calculate Energies for Reactive Basin Outline #####
        alt_x_1s = np.linspace(0,x_lim, 100)
        x_2s = np.linspace(-x_lim,x_lim, 100)
        alt_X1grid, alt_X2grid = np.meshgrid(alt_x_1s, x_2s) 
        alt_Xs = np.vstack([alt_X1grid.flatten(), alt_X2grid.flatten()]).T
        alt_energies = self.energy(alt_Xs)
        alt_energies = alt_energies.reshape((100,100))

        # Plot Main
        plt.contourf(X1grid, X2grid, energies, 50, cmap='jet', vmax=cmax)
        cbar = plt.colorbar()
        cbar.set_label('Energy / kT')
        plt.xlabel('$x_1$')
        plt.ylabel('$x_2$', labelpad=-10)
        # Plot Basin
        plt.contour(alt_X1grid, alt_X2grid, alt_energies, levels=[self.params['k_BH']], colors='white', linewidths=5, linestyles='--')

        # Calculate energy at key locations
        key_locs = np.array([[-1,0],[0,0],[1,0]])
        key_energies = self.energy(key_locs)
        adj = np.array([0.1, 0.05])
        for key_loc, key_energy in zip(key_locs, key_energies):
            plt.text(*(key_loc-adj), str(key_energy), color='white', fontsize=30)
        plt.show()

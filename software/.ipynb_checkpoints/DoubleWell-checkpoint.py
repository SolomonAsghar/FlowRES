import numpy as np
import tensorflow as tf
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from matplotlib.colors import ListedColormap


class DoubleWell():
    '''
    Contains functions relevant to Double Well potential model.

    params [dict]: Parameters that define the double well: k_x, x_0, k_BH, k_y
    xmin [float]: xmin applied to plots generated by plotting functions in this class
    xmax [float]: As above but xmas
    ymin [float]: As above but ymin
    ymax [float]: As above but ymas
    '''

    def __init__(self, params=None,
                 xmin=None, xmax=None, ymin=None, ymax=None):
        self.params = params
        self.xmin = xmin
        self.xmax = xmax
        self.ymin = ymin
        self.ymax = ymax

    def energy_xy(self, x, y):
        '''
        Takes xy and returns energy
        '''
        return ((self.params['k_x']*((x**2) - (self.params['x_0']**2))**2) + ((self.params['k_y']/2)*(y**2))) * (self.params['k_BH']/2)
        
        
    def energy(self, X, input_mode='Traj'):
        '''
        Takes path(s) and returns the energy 

        X [numpy array]: Array containing the path(s)
        input_mode ['Traj' or 'Batch']: Does X contain a simple path, or a batch of paths?
        '''
        if input_mode == 'Traj':
            x = X[:,0]
            y = X[:,1]
        if input_mode == 'Batch':
            x = X[:,:,0]
            y = X[:,:,1]
        
        return self.energy_xy(x,y)
        
        
    def batch_gradient(self, X, mode, dX=0.001):
        '''
        Returns the gradient of the energy of the paths passed to it. 

        X [numpy array]: Array containing the path(s)
        mode ['numpy' or 'TF']: Should this function use numpy or tensorflow operations. Use 'TF' when calling this as part of network training. 
        dX [float]: Delta used for numerical differentiation
        '''
        x = X[:,:,0]
        y = X[:,:,1]
        
        x_pl_dX = x + dX
        x_mi_dX = x - dX
        x_pl_Energy = self.energy_xy(x_pl_dX, y)
        x_mi_Energy = self.energy_xy(x_mi_dX, y)
        grad_Ux = (x_pl_Energy - x_mi_Energy)/(2*dX)

        y_pl_dX = y + dX
        y_mi_dX = y - dX
        y_pl_Energy = self.energy_xy(x, y_pl_dX)
        y_mi_Energy = self.energy_xy(x, y_mi_dX)
        grad_Uy = (y_pl_Energy - y_mi_Energy)/(2*dX)

        if mode == 'numpy':
            grad_U = np.stack((grad_Ux, grad_Uy), axis=2)
        elif mode == 'TF':
            grad_U = tf.stack((grad_Ux, grad_Uy), axis=2)
        
        return grad_U

    def plot_free_energy(self):
        '''
        Plots the changes in free energy with x_1
        '''
        x_1s = np.linspace(-2,2, 200)[:,None]
        x_2s = np.zeros((x_1s.size,1))
        Xs = np.hstack((x_1s, x_2s))
        energies = self.energy(Xs)
        
        import matplotlib.pyplot as plt
        ax = plt.gca()
        ax.set_xlabel('$x_1$ / a.u.')
        ax.set_ylabel('Energy / kT')
        ax.set_ylim(energies.min()-2, energies[int(energies.size/2)]+2.5)
        
        return ax.plot(x_1s, energies, linewidth=3, color='black')      
   

    def plot_energy_surface_DW(self, x_lim=2):
        '''
        Generates a contour plot showing the energy landscape
        '''
        plt.rcParams['figure.figsize'] = 9.5, 7.5
        plt.rcParams['font.size'] = 30
        fsz = 33

        # Define custom camp #
        viridis = mpl.colormaps['viridis']
        viridis_new_colors = viridis(np.linspace(0,1,1000)**0.5)
        viridis_2 = ListedColormap(viridis_new_colors)

        # Calculate Energies for Main Plot
        x_1s = np.linspace(-x_lim,x_lim, 100)
        X1grid, X2grid = np.meshgrid(x_1s, x_1s) # x_2s = x_1s
        Xs = np.vstack([X1grid.flatten(), X2grid.flatten()]).T
        energies_raw = self.energy(Xs)
        energies_raw = np.maximum(energies_raw, 0)
        energies = energies_raw.reshape((100,100))
        ##### Calculate Energies for Reactive Basin Outline #####
        alt_x_1s = np.linspace(0,x_lim, 100)
        x_2s = np.linspace(-x_lim,x_lim, 100)
        alt_X1grid, alt_X2grid = np.meshgrid(alt_x_1s, x_2s)
        alt_Xs = np.vstack([alt_X1grid.flatten(), alt_X2grid.flatten()]).T
        alt_energies = self.energy(alt_Xs)
        alt_energies = alt_energies.reshape((100,100))

        # Plot Main
        cs = plt.contourf(X1grid, X2grid, energies, 100, cmap=viridis_2)
        cbar = plt.colorbar(cmap=viridis_2, location='right', ticks=[0, np.max(energies)])
        cbar.set_label('Energy $(k_\mathrm{B}T_\mathrm{eff})$', labelpad=-10)
        # cbar.ax.set_yticklabels(['0', 'max'])

        plt.xticks([])
        plt.yticks([])
        # Plot Basin
        plt.contour(alt_X1grid, alt_X2grid, alt_energies, levels=[self.params['target']], colors='white', linewidths=5, linestyles='--')
        plt.plot(-1,0, marker='X', color='white', markersize=20)
        # Calculate energy at key locations

        plt.contour(X1grid, X2grid, energies, levels=np.linspace(0,np.max(energies),13), colors='white', alpha=1.0, linewidths=1.0)

        # Add the scale bar
        patch_color = 'black'
        rect = patches.Rectangle((-(x_lim-0.15), x_lim-0.2), 1, 0.05, linewidth=1, edgecolor='None', facecolor=patch_color, zorder=10)
        ax1 = plt.gca()
        ax1.add_patch(rect)      
        ax1.text(-(x_lim-0.65), x_lim-0.275, "1", color=patch_color, fontsize=fsz,
                 horizontalalignment='center', verticalalignment='top', zorder=10)

        plt.show()